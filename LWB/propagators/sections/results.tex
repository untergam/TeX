\section{Results}
\label{sec:results}
%
The newly developed code was used to carry out some numerical experiments which are presented in this section.
Aspects that need to be checked are the correctness of the propagators from a quantum mechanical point of view (subsection~\ref{subsec:physical}), convergence of the methods (subsection~\ref{subsec:convergence}) and benchmarking of the compute time (subsection~\ref{subsec:benchmark}).
\par\medskip
%
The potentials used for the numerical experiments were the simple harmonic potential and the Henon-Heiles potential.
In both cases, the basis size $| \K | = 4$ was used.
\par\medskip
%
The generalized harmonic potential
\begin{align}
	\label{math:harmonic}
	V(\bvec{x}) = \frac{1}{2} \sum_{i=1}^D x_i^2
\end{align}
%
was used with initial values $\bvec{q} = (1,\dots,1)^T$ and $\bvec{q} = (1,\dots,1,-1,\dots,-1)$ that were normalized to a $L_2$ norm of $0.5$ and $0.8$ respectively.
$\bmat{Q}$ was the identity matrix and $\bmat{P} = \im \bmat{Q}^{-1}$. \\
\par\medskip
%
The two dimensional Henon-Heiles potential is given by
%
\begin{align}
	\label{math:henonheiles}
	V(\bvec{x}) = \frac{1}{2} \left( x_1^2 + x_2^2 \right) + \sigma_* \left( x_1^2 x_2 - \frac{1}{3} x_2^3 \right)
\end{align}
%
where $\sigma_*$ is a mixing coefficient that was chosen to be equal to $0.2$.
The initial values for this potential were $\bvec{q}=(1.8,0)^T$, $ \bvec{p}=(0,1.2)^T$, $\bmat{Q} = \sqrt{2} \cdot \text{diag}( \sqrt{0.56}, \sqrt{0.24} )$ and $\bmat{P} = \im \bmat{Q}^{-1}$)


\subsection{Physical Correctness}
\label{subsec:physical}
%
In order to analyze the physical correctness of the implemented propagators, a two dimensional wave packet was propagated in the Harmonic potential and in the Henon-Heiles potential presented above with each of the presented propagators for a time $T = 10$ with timestep $\Dt = 0.01$.
All propagators used the \emph{LT} splitting coefficients for the \proc{IntSplit} method.
\par\medskip
%
%
Figure \ref{fig:energy_Semiclassical} shows the time evolution of energy and the energy drift for the semiclassical propagator. The corresponding energy plots for the remaining propagators can be found in the appendix to the report. \\
As is clearly shown by the graphs, the propagators conserve the total energy (apart from very small oscillations).
%
\begin{figure}[ht]
	\centering
	\begin{minipage}[c]{\textwidth}
		\begin{center}
			\large Semiclassical Propagator \\[1mm]
			\normalsize Energy Evolution and Drift
			\vspace{4mm}
		\end{center}
	\end{minipage}
	\includegraphics[width=.45\textwidth]{figures/harmonic_energies_Semiclassical.png}
	\includegraphics[width=.45\textwidth]{figures/harmonic_drift_Semiclassical.png} \\
	\includegraphics[width=.45\textwidth]{figures/henon_energies_Semiclassical.png}
	\includegraphics[width=.45\textwidth]{figures/henon_drift_Semiclassical.png}
	\caption{Energy evolution and drift for a 2D wave packet propagated with the Semiclassical propagator in a harmonic potential (top) and a Henon-Heiles potential (bottom).
	($T = 10$, $\Dt = 0.01$, $| \K | = 4$, \emph{LT} splitting)}
	\label{fig:energy_Semiclassical}
\end{figure}


\subsection{Effect of Stepsize}
\label{subsec:convergence}
%
A convergence analysis was carried out in which the error of each propagator was recorded while reducing the stepsize $\Dt$.
A Semiclassical propagator with \emph{KL10} splitting coefficients and step size $0.001$ was used to propagate the wave packet to a final time $T = 10$ and create a reference solution.
\par\medskip
%
The error between two wave packets was computed by evaluating them on a grid with 1000 grid points and taking the $L_2$ norm of the differences.
Figure \ref{fig:error_analysis} shows the error for different step sizes $\Dt$.
It is quite surprising how the Hagedorn Propagator has higher precision than the other schemes in the case of \emph{LT} splitting.
Only for higher order splitting coefficients like \emph{Y4} the advantages of \proc{IntSplit} start paying off and the other propagators show their advantages over the simplistic Hagedorn Propagator.
%
\begin{figure}[ht]
	\centering
	\includegraphics[width=.8\textwidth]{figures/error_analysis_lt.png} \\
	\includegraphics[width=.8\textwidth]{figures/error_analysis_y4.png}
	\caption{Convergence of the various propagators towards the reference solution for \emph{LT} splitting (top) and \emph{Y4} splitting (bottom). The $L_2$ norm was measured by projecting the wave function on a grid with $1000$ nodes in the range $[-1,1]$ and taking the differences of these values.}
	\label{fig:error_analysis}
\end{figure}

\subsection{Benchmark}
\label{subsec:benchmark}
%
In order to benchmark the code, three timing experiments were carried out: a simple comparison of runtimes for different propagators, an investigation of the computational cost associated with the usage of high order splitting schemes, and an analysis of the compute time as a function of the dimension $D$.
In all cases, the harmonic potential introduced at the beginning of this section was used.
\par\medskip
%
The runtime analysis was carried out on a Linux (Kernel 4.8.7, Fedora 24 Workstation) Quad-Core machine with an Intel Core i5-3210M Processor and
4GB of RAM. The C++ code was compiled with the GNU compiler, version 6.2.1, and using the \emph{-Ofast} optimization flag.




\subsubsection{Comparison of propagators}
%
A quick comparison of timings for the different propagators is shown in table \ref{tab:speedup}, the same setup as for the energy analysis was used (2D wave packet, $T = 10$, step size $\Dt = 0.01$, \emph{LT} time splitting coefficients).
The Magnus Propagator \emph{MG4} is cheaper than expected, as it involves two evaluations of $\matrixel{\varphi_k}{W}{\varphi_l}$ per time step but is only slightly slower than the Semiclassical operator with one evaluation of the inner product.
The slowest propagator is \emph{McL84} which involves five propagations with $\opW$ per step.
%
\begin{table}[ht]
	\centering
	\begin{tabular}{|l | r |} 
		\hline
		\multicolumn{1}{|c}{\textbf{Propagator}} &
		\multicolumn{1}{|c|}{\textbf{Timing [s]}} \\
		\hline
		Hagedorn & 1.06 \\
		Semiclassical & 1.14 \\
		MG4 & 1.23 \\
		McL42 & 1.39 \\
		McL84 & 2.08 \\
		Pre764 & 1.63 \\
		\hline
	\end{tabular}
	\caption{Runtimes for propagating a 2D wave packet to a time $T = 10$ with timestep $\Dt = 0.01$ with different propagators in C++. All the timings in the table were measured by taking the average of 10 independent runs. The standard deviation of these measurements was below $1\%$.}
	\label{tab:speedup}
\end{table}


\subsubsection{Splitting Schemes}
%
As mentioned previously, the splitting coefficients $\{ w_T, w_U \}$ that are used as weights on the timestep $\dt$ in the \proc{IntSplit} method can have vastly different complexity, ranging from the \emph{Lie-Trotter} coefficients (one coefficient for propagation with $\opT$, one for propagation with $\opU$) up to the \emph{KL10} coefficients (34 coefficients for each operator). \\
Higher order schemes are usually preferred in terms of accuracy, but they come at the price of longer computation time.
\par\medskip
%
Therefore, a numerical experiment was carried out in order to analyze how much computational time is consumed for coefficient pairs of different sizes.
In order to create a reference solution, the Semiclassical Propagator was used to propagate a two dimensional wave packet in a harmonic potential over a time of $T = 400$ and with stepsize $\Dt = 0.01$.
The same simulation was carried out for coefficient pairs of various different sizes and were run in Python as well as C++.
The results are listed in table \ref{tab:benchmarksplit_t} and plotted in figure \ref{fig:benchmarksplit_f}.
\par\medskip
%
Looking at the Python timings only, the measurements suggest that in the case of the \emph{KL10} coefficient set, at least 80\% of the total runtime is spend in the \proc{IntSplit} function (since larger coefficient sets $\{ w_T, w_U \}$ only affect the number of steps with operators $\opT$ and $\opU$, but not with operator $\opW$).
\par\medskip
%
When bringing the timings in context with the C++ code, a comparison of absolute runtimes is of course not fair since C++ is intrinsically faster than a scripting language like Python and the C++ version has been optimized for speed in many different ways.
However, a very significant result in the context of the work on Propagators is how the speedup increases for larger coefficient pairs.
Using the \emph{KL10} coefficient set instead of a simple \emph{LT} set, the Python code takes more than six times longer.
The same comparison on C++ code shows that the code takes only 30\% longer for the large coefficient set than it takes for the minimal coefficient set.
This is a very encouraging result as it means that high order splitting coefficients come at almost no extra cost.
\par\medskip
%
\begin{table}[ht]
	\centering
	\begin{tabular}{|l | r | r | r | r |} 
		\hline
		\multicolumn{1}{|c}{\textbf{Splitting}} &
		\multicolumn{1}{|c}{\textbf{No. of coefs}} &
		\multicolumn{1}{|c}{\textbf{Python timing [s]}} &
		\multicolumn{1}{|c}{\textbf{C++ timing [s]}} &
		\multicolumn{1}{|c|}{\textbf{Speedup}} \\
		\hline
		LT & 1 & 174.6 & 5.766 &\textbf{30.3} \\ 
		S2 & 2 & 202.9 & 5.706 &\textbf{35.6} \\
		Y4 & 4 & 258.6 & 5.861 &\textbf{44.1} \\
		PRKS6 & 7 & 341.0 & 5.995 &\textbf{56.9} \\ 
		Y61 & 8 & 366.0 & 6.004 &\textbf{61.0} \\
		KL6 & 10 & 421.4 & 6.124 &\textbf{68.8} \\
		BM63 & 15 & 557.1 & 6.467 &\textbf{86.2} \\ 
		KL8 & 18 & 634.8 & 6.637 &\textbf{95.6} \\
		KL10 & 34 & 1067.2 & 7.457 &\textbf{143.1} \\
		\hline
	\end{tabular}
	\caption{Table comparing the computation time of Python code vs. C++ code for different sizes of the splitting coefficients $\{ w_T, w_U \}$. All the timings in the table were measured by taking the average of 10 independent runs. The standard deviation of these measurements was below $1\%$ for the Python timings and below $0.1\%$ for the C++ timings.}
	\label{tab:benchmarksplit_t}
\end{table}
%
\begin{figure}[ht]
	\centering
	\begin{center}
	\includegraphics[width=.8\textwidth]{figures/coefficient_analysis.png}
	\end{center}
	\caption{Comparison of computation times for different splitting coefficients $\{ w_T, w_U \}$. The absolute timings are shown in the top graph, the speedup on the bottom. It is remarkable that the initial speedup factor is about 30, but grows for larger coefficient sets. The speedup factor for the largest tested coefficient pair \emph{KL10} is over 140.}
	\label{fig:benchmarksplit_f}
\end{figure}


\subsubsection{Scaling with dimensionality D}
%
The question that was addressed in this benchmark is how the compute time of the code scales with increasing dimension $D$ of the wave packet.
Figure \ref{fig:dimension_analysis} shows a clear exponential scaling with the dimension $D$.
With a computation time of under 20 minutes for 100 time steps with the Semiclassical Propagator, dimension $D=5$ is still quite feasible.
%
\begin{figure}[ht]
	\centering
	\includegraphics[width=.8\textwidth]{figures/dimension_analysis.png}
	\caption{Scaling of the computation time with wave packet dimension $D$. Measurements done for a wave packet in a generalized harmonic potential, propagated for 100 steps with the Semiclassical Propagator.}
	\label{fig:dimension_analysis}
\end{figure}
